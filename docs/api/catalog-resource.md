---
title: NuGet V3 API のカタログ リソース
description: カタログは、すべてのパッケージが作成され、nuget.org の削除のインデックスです。
author: joelverhagen
ms.author: jver
ms.date: 10/30/2017
ms.topic: reference
ms.reviewer: kraigb
ms.openlocfilehash: 8e4fb376e471a207333d241aeb414da7d5c3571e
ms.sourcegitcommit: 2a9d149bc6f5ff76b0b657324820bd0429cddeef
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/01/2019
ms.locfileid: "67496538"
---
# <a name="catalog"></a>Catalog

**カタログ**リソースの作成と削除などのパッケージ ソースのすべてのパッケージ操作の記録です。 カタログ リソースは、`Catalog`で入力、[サービス インデックス](service-index.md)します。 このリソースを使用する[パッケージが公開されているすべてのクエリ](../guides/api/query-for-all-published-packages.md)します。

> [!Note]
> カタログが、公式の NuGet クライアントによって使用されていないために、すべてのパッケージのソースはカタログを実装します。

> [!Note]
> 現時点では、nuget.org のカタログでは、中国で使用できません。 詳細については、次を参照してください。 [Nuget/nugetgallery #4949](https://github.com/NuGet/NuGetGallery/issues/4949)します。

## <a name="versioning"></a>バージョン管理

次`@type`値が使用されます。

@type の値   | メモ
------------- | -----
Catalog/3.0.0 | 最初のリリース

## <a name="base-url"></a>[基本 URL]

次の api エントリ ポイントの URL の値である、`@id`前述のリソースに関連付けられたプロパティ`@type`値。 このトピックでは、プレース ホルダー URL を使用して`{@id}`します。

## <a name="http-methods"></a>HTTP メソッド

HTTP メソッドのみをカタログ リソースのサポートで検出されたすべての Url`GET`と`HEAD`します。

## <a name="catalog-index"></a>カタログ インデックス

カタログ インデックスは、時系列順に並べ、カタログ アイテムの一覧がある既知の場所でドキュメントです。 カタログ リソースのエントリ ポイントです。

インデックスは、カタログ ページで構成されます。 カタログの各ページには、カタログ項目が含まれています。 各カタログ項目は、時間の時点で 1 つのパッケージに関連イベントを表します。 カタログ アイテムには、作成された、一覧にない、一覧に再記載、または削除されたパッケージ ソースからパッケージを表すことができます。 時系列順でカタログ アイテムを処理することによって、クライアントは、V3 パッケージ ソースに存在するすべてのパッケージの最新の状態のビューを構築できます。

つまり、カタログの blob には、次の階層構造があります。

- **インデックス**: カタログのエントリ ポイント。
- **ページ**: カタログ アイテムのグループ化します。
- **リーフ**: 1 つのパッケージの状態のスナップショットは、カタログ アイテムを表すドキュメント。

カタログの各オブジェクトがという名前のプロパティ、`commitTimeStamp`アイテムがカタログに追加されたときを表します。 カタログ項目は、コミットと呼ばれるバッチでのカタログ ページに追加されます。 同じコミット内のすべてのカタログ項目が同じコミット タイムスタンプがある (`commitTimeStamp`) とコミット ID (`commitId`)。 カタログ項目が同じコミット内に配置では、パッケージ ソースでの同じ点を中心に発生したイベントを表します。 カタログ コミット内で順序がありません。

各パッケージ ID とバージョンは、一意であるためにはことはありませんは、複数のカタログ項目にはコミットします。 これにより、1 つのパッケージ用のカタログ アイテム常に明確に順序を指定できますに関しては、コミット タイムスタンプ。

カタログごとに 1 つ以上のコミットにならない`commitTimeStamp`します。 つまり、`commitId`が重複して、`commitTimeStamp`します。

異なり、[パッケージ メタデータ リソース](registration-base-url-resource.md)、パッケージ ID によってインデックスが作成されるカタログ、インデックスが (クエリ可能な) 時間によってのみです。

カタログ アイテムは常に 1 ずつ増加、時系列順でカタログに追加します。 つまり、ことカタログ コミットは時刻 X に追加された場合、カタログのコミットはまったく追加しないことで X 少ないの時間。

次の要求は、カタログ インデックスをフェッチします。

    GET {@id}

カタログ インデックスは、次のプロパティを持つオブジェクトを含む JSON ドキュメントを示します。

名前            | 種類             | 必須 | メモ
--------------- | ---------------- | -------- | -----
commitId        | string           | 可      | 最新のコミットに関連付けられている一意の ID
commitTimeStamp | string           | 可      | 最新のコミットのタイムスタンプ
count           | integer          | 可      | インデックス内のページの数
items           | オブジェクトの配列 | 可      | 各オブジェクト、ページを表す、オブジェクトの配列

内の各要素、`items`配列は、各ページに関するいくつかの最小限の情報を持つオブジェクト。 これらのページ オブジェクトでは、カタログ リーフ (アイテム) は含まれません。 この配列内の要素の順序が定義されていません。 使用したメモリ内のクライアントからページの順序を指定できます、`commitTimeStamp`プロパティ。

新しいページが導入されていると、`count`が増分され、新しいオブジェクトに表示されます、`items`配列。

カタログ、インデックスの項目が追加された`commitId`変更は、`commitTimeStamp`が増加します。 これら 2 つのプロパティは概要では基本的にすべてのページ`commitId`と`commitTimeStamp`値、`items`配列。

### <a name="catalog-page-object-in-the-index"></a>インデックス内のカタログ ページ オブジェクト

カタログ インデックスのカタログ ページ オブジェクトが見つかった`items`プロパティの次のプロパティがあります。

名前            | 種類    | 必須 | メモ
--------------- | ------- | -------- | -----
@id             | string  | 可      | フェッチのカタログ ページの URL
commitId        | string  | 可      | このページで最新のコミットに関連付けられている一意の ID
commitTimeStamp | string  | 可      | このページで最新のコミットのタイムスタンプ
count           | integer | 可      | カタログ ページ内の項目の数

異なり、[パッケージ メタデータ リソース](registration-base-url-resource.md)インラインのケースでは、いくつかのインデックスにまま、カタログ リーフ インデックスにインライン展開されないし、ページを使用して常にフェッチする必要があります`@id`URL。

### <a name="sample-request"></a>要求のサンプル

    GET https://api.nuget.org/v3/catalog0/index.json

### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-index.json](./_data/catalog-index.json)]

## <a name="catalog-page"></a>[カタログ] ページ

カタログ ページには、カタログ アイテムのコレクションです。 いずれかを使用してフェッチ ドキュメントでは、`@id`カタログ インデックスで値が見つかりません。 カタログ ページの URL は、予測できるものではありませんし、カタログ インデックスのみを使用して検出する必要があります。

新しいカタログ項目は、最高のコミット タイムスタンプでのみカタログ インデックス内のページまたは新しいページに追加されます。 コミット タイムスタンプが上位のページをカタログに追加すると、古いページは決して追加または変更。

カタログ ページのドキュメントでは、次のプロパティを持つ JSON オブジェクトです。

名前            | 種類             | 必須 | メモ
--------------- | ---------------- | -------- | -----
commitId        | string           | 可      | このページで最新のコミットに関連付けられている一意の ID
commitTimeStamp | string           | 可      | このページで最新のコミットのタイムスタンプ
count           | integer          | 可      | ページ内の項目の数
items           | オブジェクトの配列 | 可      | このページでカタログ アイテム
parent          | string           | 可      | カタログ インデックスへの URL

内の各要素、`items`配列は、カタログ項目に関するいくつかの最小限の情報を持つオブジェクト。 これらの項目オブジェクトでは、すべてのカタログ項目のデータは含まれません。 ページの項目の順序`items`配列が定義されていません。 メモリを使用して、クライアントによって項目の順序を指定できます、`commitTimeStamp`プロパティ。

ページでカタログ アイテムの数は、サーバーの実装によって定義されます。 Nuget.org の場合最大 550 にアイテムが各ページで、実際の数は、時間の時点で、次のコミット バッチのサイズによっては一部のページの小さい場合がありますがします。

新しい項目が導入されていると、`count`にインクリメントされると、新しいカタログ項目オブジェクトが表示、`items`配列。

項目が、ページに追加されると、`commitId`変更と`commitTimeStamp`が増加します。 これら 2 つのプロパティのすべての概要では基本的は`commitId`と`commitTimeStamp`値、`items`配列。

### <a name="catalog-item-object-in-a-page"></a>ページ内の項目のオブジェクトをカタログします。

カタログ項目のオブジェクトが、カタログ ページで見つかった`items`プロパティの次のプロパティがあります。

名前            | 種類    | 必須 | メモ
--------------- | ------- | -------- | -----
@id             | string  | 可      | カタログ項目をフェッチする URL
@type           | string  | 可      | カタログ項目の種類
commitId        | string  | 可      | このカタログ アイテムに関連付けられたコミット ID
commitTimeStamp | string  | 可      | このカタログ アイテムのコミット タイムスタンプ
nuget:id        | string  | 可      | このリーフに関連するパッケージ ID
nuget:version   | string  | 可      | このリーフに関連するパッケージのバージョン

`@type`値には、次の 2 つの値のいずれかになります。

1. `nuget:PackageDetails`: これに対応して`PackageDetails`カタログ リーフ ドキュメントの種類。
1. `nuget:PackageDelete`: これに対応して、`PackageDelete`カタログ リーフ ドキュメントの種類。

どのような各型の意味を参照してください詳細については、[項目の種類を対応する](#item-types)以下。

### <a name="sample-request"></a>要求のサンプル

    GET https://api.nuget.org/v3/catalog0/page2926.json

### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-page.json](./_data/catalog-page.json)]

## <a name="catalog-leaf"></a>カタログ リーフ

カタログ リーフには、時間内の特定のパッケージ ID といくつかの時点のバージョンに関するメタデータが含まれています。 使用してフェッチ ドキュメントでは、`@id`カタログ ページで値が見つかりました。 カタログ リーフを URL では、予測できるものではありませんし、カタログ ページのみを使用して検出する必要があります。

カタログ リーフ ドキュメントでは、次のプロパティを持つ JSON オブジェクトです。

名前                    | 種類                       | 必須 | メモ
----------------------- | -------------------------- | -------- | -----
@type                   | 文字列または文字列の配列 | 可      | カタログ アイテムの種類
catalog:commitId        | string                     | 可      | このカタログ アイテムに関連付けられたコミット ID
catalog:commitTimeStamp | string                     | 可      | このカタログ アイテムのコミット タイムスタンプ
id                      | string                     | 可      | カタログ アイテムのパッケージ ID
published               | string                     | 可      | パッケージのカタログ アイテムの発行日
version                 | string                     | 可      | カタログ アイテムのパッケージのバージョン

### <a name="item-types"></a>項目の種類

`@type`プロパティは、文字列または文字列の配列。 便宜上場合、`@type`値は、文字列、1 つのサイズの配列として扱う必要があります。 すべての可能な値`@type`は記載されています。 ただし、各カタログ アイテムには、次の 2 つの文字列型値の 1 つだけがあります。

1. `PackageDetails`: パッケージのメタデータのスナップショットを表します
1. `PackageDelete`: 削除されたパッケージを表します

### <a name="package-details-catalog-items"></a>カタログ アイテムのパッケージの詳細

型を持つ項目をカタログ`PackageDetails`(ID とバージョンの組み合わせ) の特定のパッケージのパッケージ メタデータのスナップショットが含まれます。 パッケージ ソースを検出すると、次のシナリオのいずれかのパッケージの詳細のカタログ項目が生成されます。

1. パッケージは、**プッシュ**します。
1. パッケージは、**表示**します。
1. パッケージは、**一覧にない**します。
1. パッケージは、**折り返す**します。

パッケージのリフローでは、基本的に、パッケージ自体を変更せずに既存のパッケージの偽のプッシュを生成する管理用のジェスチャです。 Nuget.org には、カタログを使用するバック グラウンド ジョブのいずれかでバグを修正した後、リフローが使用されます。

クライアントが、カタログ項目を使用しようとしないでくださいカタログ項目を生成すると、これらのシナリオを決定します。 代わりに、クライアント更新必要がありますだけです、保持しているビューまたはパーティション インデックス カタログ アイテムに含まれるメタデータを使用します。 重複するカタログ アイテムを適切に処理する必要がありますさらに、(冪等)。

パッケージの詳細のカタログ項目があるものに加えて、次のプロパティ[すべてのカタログ リーフに含まれている](#catalog-leaf)します。

名前                    | 種類                       | 必須 | メモ
----------------------- | -------------------------- | -------- | -----
authors                 | string                     | Ｘ       |
created                 | string                     | Ｘ       | パッケージが最初に作成されたときのタイムスタンプ。 フォールバック プロパティ:`published`します。
dependencyGroups        | オブジェクトの配列           | Ｘ       | ターゲット フレームワークによって、パッケージの依存関係がグループ化 ([パッケージ メタデータ リソースと同じ形式](registration-base-url-resource.md#package-dependency-group))
deprecation             | object                     | Ｘ       | パッケージに関連付けられている非推奨 ([パッケージ メタデータ リソースと同じ形式](registration-base-url-resource.md#package-deprecation))
description             | string                     | Ｘ       |
iconUrl                 | string                     | Ｘ       |
isPrerelease            | boolean                    | Ｘ       | パッケージのバージョンがプレリリースかどうか。 検出できる`version`します。
language                | string                     | Ｘ       |
licenseUrl              | string                     | Ｘ       |
listed                  | boolean                    | Ｘ       | パッケージを表示するかどうか
minClientVersion        | string                     | Ｘ       |
packageHash             | string                     | 可      | 使用してエンコード、パッケージのハッシュ[標準の base 64](https://tools.ietf.org/html/rfc4648#section-4)
packageHashAlgorithm    | string                     | 可      |
packageSize             | integer                    | 可      | (バイト単位) パッケージの .nupkg のサイズ
projectUrl              | string                     | Ｘ       |
releaseNotes            | string                     | Ｘ       |
requireLicenseAgreement | boolean                    | Ｘ       | 想定`false`除外されている場合
summary                 | string                     | Ｘ       |
tags                    | 文字列の配列           | Ｘ       |
title                   | string                     | Ｘ       |
verbatimVersion         | string                     | Ｘ       | バージョン文字列が、.nuspec で見つかった最初

パッケージ`version`プロパティでは、完全なバージョン文字列を正規化後。 意味 SemVer 2.0.0 ビルド データは含まれていますここでします。

`created`タイムスタンプは、パッケージは、まずカタログ アイテムのコミット タイムスタンプより前に、の短い形式の時刻は、通常、パッケージ ソースによって受信されたときにします。

`packageHashAlgorithm`生成するために使用されるハッシュ アルゴリズムを表す、サーバーの実装によって定義された文字列には、`packageHash`します。 nuget.org が常に使用される、 `packageHashAlgorithm` @property `SHA512`。

`published`タイムスタンプは、パッケージが最後に示されている時点。

> [!Note]
> Nuget.org で、`published`値が、パッケージが一覧表示されている場合 1900 年に設定します。

#### <a name="sample-request"></a>要求のサンプル

取得 https://api.nuget.org/v3/catalog0/data/2015.02.01.11.18.40/windowsazure.storage.1.0.0.json

#### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-package-details.json](./_data/catalog-package-details.json)]

### <a name="package-delete-catalog-items"></a>パッケージ カタログ アイテムの削除

型を持つ項目をカタログ`PackageDelete`ことを示すカタログ クライアントにパッケージがパッケージ ソースから削除されましたが、パッケージの操作 (復元) などの使用できなくする情報の最小限のセットが含まれます。

> [!NOTE]
> パッケージを削除して、同じパッケージ ID とバージョンを使用して後で再公開を可能になります。 Nuget.org には、これは非常にまれなケース中断されるので、公式のクライアントの前提がパッケージ ID とバージョンが特定のパッケージ コンテンツを意味します。 Nuget.org でパッケージの削除に関する詳細については、次を参照してください。 [、弊社のポリシー](../nuget-org/policies/deleting-packages.md)します。

パッケージ カタログ アイテムの削除にものに加えて追加のプロパティがあるない[すべてのカタログ リーフに含まれている](#catalog-leaf)します。

`version`プロパティは、パッケージの .nuspec 内にある元のバージョン文字列。

`published`プロパティは、通常は、カタログ アイテムのコミット タイムスタンプより前に、の短い形式の時刻としてパッケージが削除された時間。

#### <a name="sample-request"></a>要求のサンプル

取得 https://api.nuget.org/v3/catalog0/data/2017.11.02.00.40.00/netstandard1.4_lib.1.0.0-test.json

#### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-package-delete.json](./_data/catalog-package-delete.json)]

## <a name="cursor"></a>カーソル

### <a name="overview"></a>概要

このセクションは必ずしも必須ではないプロトコルでは、実用的なカタログ クライアント実装の一部にする必要がありますクライアントの概念について説明します。

クライアントを格納する必要があります、カタログは、時間インデックスを追加専用のデータ構造体であるため、**カーソル**まで、どの時点でクライアントを表すが処理されるカタログ アイテムがローカルにします。 このカーソル値を生成しないこと、クライアントのマシンのクロックを使用してに注意してください。 代わりに、値の元のカタログ オブジェクトの`commitTimestamp`値。

たびに、クライアントがパッケージ ソースの新しいイベントを処理しようとすると、その必要がありますカタログのクエリのみ、コミット タイムスタンプのすべてのカタログ アイテムのストアド カーソルより大きい。 クライアントでは、すべての新しいカタログ項目が正常に処理、後に新しいカーソル値としてだけ処理されたカタログ項目の最新のコミット タイムスタンプを記録します。

このアプローチを使用して、クライアントはパッケージ ソースで発生したすべてのパッケージ イベントを見逃すことはありませんを確認できます。
さらに、クライアント カーソルの記録されたコミット タイムスタンプより前の古いイベントを再処理する必要はありません。

このカーソルの強力な概念は、nuget.org のバック グラウンド ジョブの多くは使用され、V3 API 自体の最新の状態を維持するために使用します。 

### <a name="initial-value"></a>初期値

カタログのクライアントが初めての開始 (とカーソル値を持たない) の既定のカーソル値を使用してください。NET の`System.DateTimeOffset.MinValue`または表現可能な最小のタイムスタンプのような類似概念です。

### <a name="iterating-over-catalog-items"></a>カタログ アイテムを反復処理します。

次の一連のカタログ項目の処理のクエリをクライアントが必要です。

1. ローカル ストアからは、カーソルの記録された値を取得します。
1. ダウンロードして、カタログ インデックスを逆シリアル化します。
1. すべてのカタログ、コミット タイムスタンプのページ検索*より大きい*カーソル。
1. カタログ項目の処理の空のリストを宣言します。
1. カタログ ページごとに手順 3. で一致します。
   1. ダウンロードして、カタログ ページを逆シリアル化します。
   1. すべてのカタログ項目、コミット タイムスタンプ検索*より大きい*カーソル。
   1. 手順 4 で宣言されているリストに一致するすべてのカタログ項目を追加します。
1. コミット タイムスタンプによってカタログ項目のリストを並べ替えます。
1. シーケンス内の各カタログ アイテムを処理します。
   1. ダウンロードして、カタログ項目を逆シリアル化します。
   1. カタログ項目の種類に適切に対処します。
   1. 特定のクライアントの方式でカタログ アイテムのドキュメントを処理します。
1. 新しいカーソル値として、前回のカタログ項目のコミット タイムスタンプを記録します。

この基本的なアルゴリズムでは、クライアントの実装は、パッケージ ソースで使用可能なすべてのパッケージの完全なビューを構築できます。 クライアントには、このアルゴリズムのパッケージ ソースを最新の変更を把握しておくには、定期的な実行のみ必要があります。

> [!Note]
> これは、アルゴリズムを使用して、nuget.org、[パッケージ メタデータ](registration-base-url-resource.md)、[パッケージ コンテンツの](package-base-address-resource.md)、[検索](search-query-service-resource.md)と[オートコンプリート](search-autocomplete-service-resource.md)リソースが最新の状態。

### <a name="dependent-cursors"></a>依存カーソル

1 つのクライアントからの出力を別のクライアントの出力に依存する場所に固有の依存関係を持つ 2 つのカタログ クライアントがあるとします。 

#### <a name="example"></a>例

たとえば、nuget.org で新たに発行されたパッケージする必要がありますに表示されません検索リソース パッケージ メタデータ リソースに表示される前に。 これは、公式の NuGet クライアントによって実行される「復元」操作は、パッケージ メタデータ リソースを使用するためです。 顧客は、search サービスを使用してパッケージを検出、パッケージ メタデータ リソースを使用してそのパッケージを正常に復元できる必要があります。 つまり、検索のリソースは、パッケージ メタデータ リソースに依存します。 各リソースでは、そのリソースの更新カタログ クライアント バック グラウンド ジョブがあります。 各クライアントには独自のカーソル。

両方のリソースが、カタログの検索のリソースを更新するカタログ クライアント カーソルから構築されているため*を超えて移動する必要がありますいない*のパッケージのメタデータ カタログ クライアント カーソル。

#### <a name="algorithm"></a>アルゴリズム

この制限を実装するために単純にするのには、上のアルゴリズムを変更します。

1. ローカル ストアからは、カーソルの記録された値を取得します。
1. ダウンロードして、カタログ インデックスを逆シリアル化します。
1. すべてのカタログ、コミット タイムスタンプのページ検索*より大きい*カーソル**以下、依存関係のカーソル。**
1. カタログ項目の処理の空のリストを宣言します。
1. カタログ ページごとに手順 3. で一致します。
   1. ダウンロードして、カタログ ページを逆シリアル化します。
   1. すべてのカタログ項目、コミット タイムスタンプ検索*より大きい*カーソル**以下、依存関係のカーソル。**
   1. 手順 4 で宣言されているリストに一致するすべてのカタログ項目を追加します。
1. コミット タイムスタンプによってカタログ項目のリストを並べ替えます。
1. シーケンス内の各カタログ アイテムを処理します。
   1. ダウンロードして、カタログ項目を逆シリアル化します。
   1. カタログ項目の種類に適切に対処します。
   1. 特定のクライアントの方式でカタログ アイテムのドキュメントを処理します。
1. 新しいカーソル値として、前回のカタログ項目のコミット タイムスタンプを記録します。

この変更されたアルゴリズムを使用するシステムを構築できます依存カタログ クライアントの独自の特定のインデックス、成果物などをすべて生成します。
